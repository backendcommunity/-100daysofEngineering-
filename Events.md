**Events in Programming**:

An event is an action or occurrence recognized by a program, and the program can react to these events. 

Events can be triggered by a user's actions, such as clicking on a button or typing, or they can be generated by the program itself.

**Event Listeners and Handlers**:

When an event occurs, the program generates a signal. Event listeners are responsible for monitoring these events as they happen and passing them on to event handlers. Event handlers, on the other hand, are blocks of code designed to respond to and handle these events. They are attached to the events and execute specific actions in response to the events passed by the event listener. Event handlers enable the program to react and respond effectively to various user actions and other events in the program's execution.


##The Event Loop

JavaScript (JS) is a single-threaded language, which means it can execute one operation at a time.

**The Call Stack**:

- The call stack is a data structure that records where the program is in its execution.
- It operates on a Last-In, First-Out (LIFO) principle, which means the last operation pushed onto the stack is the first to be executed.
- It manages the global execution context (where the program starts and executes) and function execution contexts (created for each function call).

**Blocking**:

- Blocking refers to operations or code blocks that are slow and may take a significant amount of time to execute.

**Concurrency**:

- Concurrency is the ability to execute multiple tasks or operations at seemingly the same time, even in a single-threaded environment.
- The event loop is a critical component for achieving concurrency in JavaScript.

**The Event Loop**:

- The event loop constantly monitors the call stack and the task queue (also known as the callback queue).
- When the call stack is empty (no synchronous code is executing), the event loop checks the task queue.
- Any pending tasks in the task queue are pushed onto the call stack for execution and are later removed from the stack.

**Non-Blocking I/O**:

- The event loop allows JavaScript to perform non-blocking input-output (I/O) operations.
- In Node.js, blocking operations like reading/writing files or networking tasks are offloaded to the operating system kernel, which often handles them in a multithreaded manner.
- The results of these operations are then sent to the callback queue for further processing.




Event driven architecture
Event-driven architecture is a softwqre design pattern taht enables an organisation to detect events and act on them in real time

EDA is often refered to as asynchronous communicationi because the sender and recipient do not have to wait for each other to move onto their next task. EDA is a shift from accumulating data and data lakes to focus on data in flight

EDAs have three key components: event producers, event routers/channels and event consumers.
A producer publishes/produces and event to the router
The router filters, ingests and pushes the event to the consmers. 
 
The asynchronous form of EDA suports a decoupled system, where producers are decooupled from conusermers. Producers don't know which consumers are listening for the events they are sending

EDA has two main Design patterns
- Publisher-Subscriber pattern
- Event streaming pattern

##Publisher-Subsriber pattern
Pub/Sub is a design pattern used for asynchronous communication between different components
It enables an application to announce events to multiple consumers asynchronously.
The sender packages events into messages and sends to the consumers and the consumers are known as the subscribers. The Sender here is called the publisher, messages are sent through intermediaries called message brokers which groups sthe messages into different topics (or channels). The consumers subscribe to this topics.

##Web hooks
These are automated messages that are sent from apps when something happens.
Web hooks are user defined callbacks made with an HTTP. Webhooks are data and executable commands sent from one app to another over HTTP. They are functions that run when something happens i.e. an event occurs
Webhooks are how a system updates another system about an event in real-time.
They are a means for automating responses in softwares and they are called event based APIs
They are used in social messaging apps, whereby when an event takes place such as sending a message, the sender triggers the webhook and almost immediately an update is sent to the receiver.



### How does Node.js handle asynchronous operations, and can you explain the event loop in the context of Node.js?
- Asynchronous means tasks or operations can happen concurrently or at the same time irrespective of the main program flow, i.e performing a task without waiting for the task to finish before moving to the next task instead of blocking the entire program while waiting for a task to get done. When nodejs starts an asynchronous operation, it uses a non-blocking model (event loop) such that nodejs continues with other operations while waiting for the asynchronous operation to complete. NodeJs uses callbacks (functions passed as arguments to other functions) to handle asynchronous operations, when the operation completes either successfully or with an error, the callback function passed to the asynchronous function is fired or called. ECMASCRIPT 2015 introduced the Promise object which is used to handle asynchronous operations as promises that can be resolved or rejected. This allows for chaining of multiple asynchronous operations (providing solution to callback hell) using .then() method and .catch() method to handle errors. ECMASCRIPT 2017 introduced the async/await syntax. While using async to denote asynchronous operation and await keyboard to  wait for complettion of asynchronous operation. Async keyword also denotes that the function returns a promise and await used to make sure the promise is settled either successfully or with an error. It gives the asynchronous operations the same syntax as synchronous operations, using try and catch block to catch any errors.

- While NodeJs is single-threaded - can only perform one or single i/o operation or function call at a time using a single processor and reduces overhead of multiple thread communication - the event loop allows it to perform non-blocking input/output operations or multiple operations. The event loop of NodeJs is the power house(process) for the execution flow of NodeJs which gives an illusion of multi-threadedness for NodeJs. When NodeJs starts, the event loop using the libuv library, offloads asynchronous function calls i.e. database operations, network requests, wrting/reading from file, etc (that would otherwise be blocking on the call stack because they take long to complete) to the operating system (operating systems are mostly multi-threaded threaded), the kernel handles the operations and returns the resolution to the event loop upon completion(the callback queue only accepts callback functions for completed operations only), the event loop then moves the callback function (each asynchronous function has a callback function that runs upon completion of the operation) for this asynchronous operation to the callback queue (the callback function is not called immediately upon completion of the operation), the event loops continues to check the call stack and moves the callback functions in the callback queue - using FIFO (first in first out) approach - into the call stack for execution. In summary, the event loop helps to handle long running operations, without blocking the main thread, thus makeing the program responsvie.